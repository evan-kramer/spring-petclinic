# How do Jenkins plugins help DevOps practices? 

The goal of DevOps is to maintain high quality code while reducing the time between committing changes and deploying them into production. Jenkins is a continuous integration tool that can recognize when a commit gets pushed to a remote repository (such as GitHub) and runs an automated pipeline on the code in that repository. This pipeline can include static code analysis (as in this project with SonarQube) and unit or functional tests, among others. This allows developers to automate testing and remove manual steps in the deployment process, which helps organizations ship code more quickly and with higher quality (assuming they've written robust and thoughtful tests). 

Jenkins helps with automation and providing consistent environments by implementing infrastructure as code (IaC). For example, it is possible to use Terraform, Docker, Vagrant, or other IaC tools to spin up the resources needed to run Jenkins, and these resources can be used to create consistent environments in which to build, test, and deploy code. This consistency helps shift left errors that developers might typically find late in the software development lifecycle.

Jenkins also helps reinforce good version control practices, since the version control system provides the backbone of the Jenkins pipeline. That is, deploying through Jenkins allows organizations to ensure that every change in the codebase that gets deployed will be recorded in the remote repository that is connected to the Jenkins pipeline. This practice can help teams work more efficiently to develop resilient distributed systems.


# What are alternative ways to use plugins in typical CI practices? 

One alternative to using Jenkins is GitHub actions. In my organization, we are dipping a toe into the water of continuous integration and have transitioned some of our stored procedures to GitHub actions. One can configure these to run/be deployed upon commit/push, on a schedule, or on demand. One advantage of GitHub actions is that it can introduce fewer third-party tools into the software bill of materials (SBOM). For organizations like ours (local government), this is a big selling point. We deal with lots of sensitive data, and security is a top priority. More specifically, using GitHub actions limits the number of third-party tools that need to access and store credentials. Jenkins needs to store GitHub credentials (or those of another version control system) in order to pull the latest version of the code. If Jenkins as a whole is compromised, attackers could access credentials and wreak havoc.